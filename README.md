# sqlbs - come up with plausible bullshit for your sql database

- The front-end guys complain that they don't really know how the UI's going to look like once more data comes in? 
- You're creating a backend and you don't know if your SQL queries really return what they are supposed to?

*Sqlbs* solves such issues by generating a bunch of insert statements based on sql schema comments specifying one of the many predefined collections. Your sample data is always as up to date as your schema. Never again write boilerplate sample data insertions that eventually get desynced from the project. Sqlbs is like fakerjs for sql!

## Getting started
- The schema for sqlbs needs to be formatted in a way where **CREATE TABLE** and each table column definition is seperated by a newline.
- Each ```CREATE TABLE``` call you want the data to be generated for needs to be annotated with one of the volume flags, specifying the amount of data you want to be generated for that given table. It is one of: low, medium, high.
- Each field you want to be autogenerated needs to be annotated by specifying the bs source. The source can either be one of the files from the atom_collections directory or a function coming from bs_composite.go. The latter can also take arguments, such as the **num function** specifying the range you want the number to be generated within. These are seperated by a semicolon.

#### In practice, an annotated schema would look like:
```
CREATE TABLE groups ( --bs: low
        id INTEGER NOT NULL PRIMARY KEY,
        name TEXT NOT NULL --bs: company
);

CREATE TABLE members ( --bs: low
        id INTEGER NOT NULL PRIMARY KEY,
        username TEXT NOT NULL, --bs: username_random
        displayName TEXT NOT NULL, --bs: fullname
        password TEXT NOT NULL --bs: val; 1234
);

CREATE TABLE member_groups ( --bs: medium
        group_id INTEGER NOT NULL, --bs: rel
        member_id INTEGER NOT NULL, --bs: rel
        PRIMARY KEY (group_id, member_id),
        FOREIGN KEY (group_id) REFERENCES groups (id),
        FOREIGN KEY (member_id) REFERENCES members (id)
);
CREATE TABLE items ( --bs: medium
        id INTEGER PRIMARY KEY NOT NULL,
        timestamp INTEGER NOT NULL, --bs: timestamp_epoch
        name TEXT NOT NULL, --bs: product
        price REAL NOT NULL, --bs: num; 1to200
        author_id INTEGER NOT NULL, --bs: rel
        group_id INTEGER NOT NULL, --bs: rel
        reimbursement BOOLEAN DEFAULT 0, --bs: bool; 0.5
        FOREIGN KEY (group_id) REFERENCES groups (id),
        FOREIGN KEY (author_id) REFERENCES members (id)
);
```

now run **sqlbs yourschemafile.sql** which prints insert statements that you can then pipe to the db tool of your choice. For sqlite, you would usually run something like:
```sqlite3 data.db < schema.sql && sqlbs schema.sql | sqlite3 data.db```
